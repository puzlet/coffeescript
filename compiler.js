// Generated by CoffeeScript 1.3.3

/*
TODO:
*/


(function() {
  var Compiler, Evaluator, Inspector, ObjectProperty, arrayToHash, hasOwn, inspect, isArray, isBoolean, isDate, isError, isFunction, isNull, isNumber, isObject, isRegExp, isString, isUndefined, objectKeys, objectToString, reduce, stylizeNoColor, stylizeWithColor, _extend;

  window.$coffee = {};

  $coffee.compile = function(spec) {
    var bare, code, js, postJs, postProcess, preProcess, preProcessedCode, _ref, _ref1;
    code = spec.code, preProcess = spec.preProcess, postProcess = spec.postProcess, bare = spec.bare;
    preProcessedCode = (_ref = typeof preProcess === "function" ? preProcess(code) : void 0) != null ? _ref : code;
    js = CoffeeScript.compile(preProcessedCode, {
      bare: bare != null ? bare : false
    });
    return postJs = (_ref1 = typeof postProcess === "function" ? postProcess(js) : void 0) != null ? _ref1 : js;
  };

  $coffee.evaluate = function(spec) {
    var code, js, postProcess, preProcess;
    code = spec.code, preProcess = spec.preProcess, postProcess = spec.postProcess, js = spec.js;
    if (!js) {
      js = $coffee.compile({
        code: code,
        preProcess: preProcess,
        postProcess: postProcess
      });
    }
    eval(js);
    return js;
  };

  Compiler = (function() {

    function Compiler(spec) {
      var _ref;
      this.spec = spec;
      _ref = this.spec, this.id = _ref.id, this.preProcess = _ref.preProcess, this.postProcess = _ref.postProcess;
      this.head = document.head;
    }

    Compiler.prototype.compile = function(code) {
      this.code = code;
      console.log("Compile " + this.id);
      if (this.findScript()) {
        this.head.removeChild(this.element[0]);
      }
      this.element = $("<script>", {
        type: "text/javascript",
        "data-url": this.id
      });
      this.js = $coffee.compile({
        code: this.code,
        preProcess: this.preProcess,
        postProcess: this.postProcess
      });
      this.element.text(this.js);
      return this.head.appendChild(this.element[0]);
    };

    Compiler.prototype.findScript = function() {
      return $("[data-url='" + this.id + "']").length;
    };

    return Compiler;

  })();

  Evaluator = (function() {

    Evaluator.prototype.noEvalStrings = [")", "]", "}", "\"\"\"", "else", "try", "catch", "finally", "alert", "console.log"];

    Evaluator.prototype.lf = "\n";

    function Evaluator(spec) {
      var _ref;
      this.spec = spec;
      _ref = this.spec, this.id = _ref.id, this.preProcess = _ref.preProcess, this.postProcess = _ref.postProcess;
      this.js = null;
    }

    Evaluator.prototype.compile = function(code) {
      var codeLines, compile, js, l, n, recompile, stringify, _ref;
      this.code = code;
      console.log("Evaluate " + this.id);
      $coffee.evaluating = this.id;
      recompile = true;
      stringify = true;
      compile = recompile || !(this.evalLines && this.js);
      if (compile) {
        codeLines = this.code.split(this.lf);
        if ((_ref = $coffee["eval"]) == null) {
          $coffee["eval"] = {};
        }
        $coffee["eval"]["" + this.id] = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = codeLines.length; _i < _len; _i++) {
            l = codeLines[_i];
            _results.push(this.isComment(l) && stringify ? l : "");
          }
          return _results;
        }).call(this);
        this.evalLines = ((function() {
          var _i, _len, _results;
          _results = [];
          for (n = _i = 0, _len = codeLines.length; _i < _len; n = ++_i) {
            l = codeLines[n];
            _results.push((this.noEval(l) ? "" : "$coffee.eval['" + this.id + "'][" + n + "] = ") + l);
          }
          return _results;
        }).call(this)).join(this.lf);
        js = null;
      } else {
        js = this.js;
      }
      try {
        this.js = $coffee.evaluate({
          code: this.evalLines,
          preProcess: this.preProcess,
          postProcess: this.postProcess,
          js: js
        });
      } catch (error) {
        console.log("eval error", error);
      }
      this.resultArray = $coffee["eval"]["" + this.id];
      this.result = this.stringify(this.resultArray);
      return this.result;
    };

    Evaluator.prototype.stringify = function(resultArray) {
      var e, result;
      return result = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = resultArray.length; _i < _len; _i++) {
          e = resultArray[_i];
          _results.push(e === "" ? "" : (e && e.length && e[0] === "#" ? e : this.objEval(e)));
        }
        return _results;
      }).call(this);
    };

    Evaluator.prototype.noEval = function(l) {
      var r, _i, _len, _ref;
      if ((l === null) || (l === "") || (l.length === 0) || (l[0] === " ") || (l[0] === "#") || (l.indexOf("#;") !== -1)) {
        return true;
      }
      _ref = this.noEvalStrings;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        r = _ref[_i];
        if (l.indexOf(r) === 0) {
          return true;
        }
      }
      return false;
    };

    Evaluator.prototype.isComment = function(l) {
      return l.length && l[0] === "#" && (l.length < 3 || l.slice(0, 3) !== "###");
    };

    Evaluator.prototype.findStr = function(str) {
      var e, idx, p, _i, _len, _ref;
      p = null;
      _ref = this.resultArray;
      for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
        e = _ref[idx];
        if ((typeof e === "string") && e === str) {
          p = idx;
        }
      }
      return p;
    };

    Evaluator.prototype.objEval = function(e) {
      var line;
      try {
        line = $inspect2(e, {
          depth: 2
        });
        line = line.replace(/(\r\n|\n|\r)/gm, "");
        return line;
      } catch (error) {
        return "";
      }
    };

    return Evaluator;

  })();

  $coffee.compiler = function(spec) {
    return new Compiler(spec);
  };

  $coffee.evaluator = function(spec) {
    return new Evaluator(spec);
  };

  /*
  Echos the value of a value. Trys to print the value out
  in the best way possible given the different types.
  
  {Object} obj The object to print out.
  {Object} opts Optional options object that alters the output.
  Adapted from node.js object inspector.
  License MIT (Â© Joyent)
  */


  inspect = function(obj, opts) {
    var inspector;
    inspector = new Inspector(obj, opts);
    return inspector.formattedObj;
  };

  Inspector = (function() {

    Inspector.prototype.lf = "\n";

    function Inspector(obj, opts) {
      var _base, _base1, _base2, _base3, _base4, _base5, _base6, _base7, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
      this.obj = obj;
      this.ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      if (arguments.length >= 3) {
        this.ctx.depth = arguments[2];
      }
      if (arguments.length >= 4) {
        this.ctx.colors = arguments[3];
      }
      if (opts) {
        _extend(this.ctx, opts);
      }
      if ((_ref = (_base = this.ctx).showHidden) == null) {
        _base.showHidden = false;
      }
      if ((_ref1 = (_base1 = this.ctx).depth) == null) {
        _base1.depth = 2;
      }
      if ((_ref2 = (_base2 = this.ctx).keysLimit) == null) {
        _base2.keysLimit = 20;
      }
      if ((_ref3 = (_base3 = this.ctx).arrayLimit) == null) {
        _base3.arrayLimit = 20;
      }
      if ((_ref4 = (_base4 = this.ctx).processJQuery) == null) {
        _base4.processJQuery = false;
      }
      if ((_ref5 = (_base5 = this.ctx).processNumericJs) == null) {
        _base5.processNumericJs = false;
      }
      if ((_ref6 = (_base6 = this.ctx).colors) == null) {
        _base6.colors = false;
      }
      if ((_ref7 = (_base7 = this.ctx).customInspect) == null) {
        _base7.customInspect = true;
      }
      if (this.ctx.colors) {
        this.ctx.stylize = stylizeWithColor;
      }
      this.formattedObj = this.formatValue(this.obj, this.ctx.depth);
    }

    Inspector.prototype.formatValue = function(value, recurseTimes) {
      var baseInfo, custom, keys, keysLimited, output, primitive, shortcut, visibleKeys, _ref,
        _this = this;
      if (custom = this.customFormat(value)) {
        return custom;
      }
      if (!this.ctx.processJQuery && value.jquery) {
        return "[jQuery]";
      }
      if (!this.ctx.processNumericJs && value.name === "numeric") {
        return "[numericjs]";
      }
      if ((typeof value === "string") && value.indexOf("eval_plot") === 0) {
        return "";
      }
      if (primitive = this.formatPrimitive(value)) {
        return primitive;
      }
      _ref = this.getKeys(value), keys = _ref.keys, visibleKeys = _ref.visibleKeys, keysLimited = _ref.keysLimited;
      if (shortcut = this.formatObjectShortcut(value, keys)) {
        return shortcut;
      }
      baseInfo = this.getBase(value);
      if (keys.length === 0 && (!baseInfo.array || value.length === 0)) {
        return base.braces[0] + baseInfo.base + baseInfo.braces[1];
      }
      if (recurseTimes < 0) {
        return this.haltProcessing(value);
      }
      this.ctx.seen.push(value);
      output = void 0;
      if (baseInfo.array) {
        output = this.formatArray(value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function(key) {
          return _this.formatProperty(value, recurseTimes, visibleKeys, key, baseInfo.array);
        });
      }
      this.ctx.seen.pop();
      return this.reduceToSingleString(output, baseInfo.base, baseInfo.braces, keysLimited);
    };

    Inspector.prototype.formatArray = function(value, recurseTimes, visibleKeys, keys) {
      var i, key, output, own, s, val, _i, _j, _len, _len1;
      output = [];
      for (i = _i = 0, _len = value.length; _i < _len; i = ++_i) {
        val = value[i];
        s = String(i);
        own = hasOwn(value, s);
        output.push(own ? this.formatProperty(value, recurseTimes, visibleKeys, s, true) : "");
      }
      for (_j = 0, _len1 = keys.length; _j < _len1; _j++) {
        key = keys[_j];
        if (!key.match(/^\d+$/)) {
          output.push(this.formatProperty(value, recurseTimes, visibleKeys, key, true));
        }
      }
      return output;
    };

    Inspector.prototype.formatProperty = function(value, recurseTimes, visibleKeys, key, array) {
      var property,
        _this = this;
      property = new ObjectProperty({
        value: value,
        recurseTimes: recurseTimes,
        visibleKeys: visibleKeys,
        key: key,
        array: array,
        ctx: this.ctx,
        formatValue: function(v, recurse) {
          return _this.formatValue(v, recurse);
        }
      });
      return property.format();
    };

    Inspector.prototype.formatObjectShortcut = function(value, keys) {
      var name;
      if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
        return this.formatError(value);
      }
      if (keys.length) {
        return null;
      }
      if (isFunction(value)) {
        name = (value.name ? ": " + value.name : "");
        return this.stylize("[Function" + name + "]", "special");
      }
      if (isRegExp(value)) {
        return this.stylize(RegExp.prototype.toString.call(value), "regexp");
      }
      if (isDate(value)) {
        return this.stylize(Date.prototype.toString.call(value), "date");
      }
      if (isError(value)) {
        return this.formatError(value);
      }
      return null;
    };

    Inspector.prototype.formatPrimitive = function(value) {
      var simple;
      if (isUndefined(value)) {
        return this.stylize("undefined", "undefined");
      }
      if (isString(value)) {
        simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, "\"") + "'";
        return this.stylize(simple, "string");
      }
      if (isNumber(value)) {
        return this.stylize("" + Math.round(value * 10000) / 10000, "number");
      }
      if (isBoolean(value)) {
        return this.stylize("" + value, "boolean");
      }
      if (isNull(value)) {
        return this.stylize("null", "null");
      }
      return null;
    };

    Inspector.prototype.formatError = function(value) {
      return "[" + Error.prototype.toString.call(value) + "]";
    };

    Inspector.prototype.haltProcessing = function(value) {
      if (isRegExp(value)) {
        return this.stylize(RegExp.prototype.toString.call(value), "regexp");
      } else {
        return this.stylize("[Object]", "special");
      }
    };

    Inspector.prototype.reduceToSingleString = function(output, base, braces, keysLimited) {
      var length, numLinesEst;
      numLinesEst = 0;
      length = reduce(output, function(prev, cur) {
        numLinesEst++;
        if (cur.indexOf(this.lf) >= 0) {
          numLinesEst++;
        }
        return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      if (length > 60) {
        return braces[0] + (base === "" ? "" : "" + (base + this.lf)) + "" + output.join(" " + this.lf) + "" + braces[1];
      }
      return braces[0] + base + "" + output.join(", ") + "" + (keysLimited ? "..." : "") + braces[1];
    };

    Inspector.prototype.getBase = function(value) {
      var array, base, braces, n;
      base = "";
      array = isArray(value);
      braces = array ? ["[", "]"] : ["{", "}"];
      if (isFunction(value)) {
        n = (value.name ? ": " + value.name : "");
        base = " [Function" + n + "]";
      }
      if (isRegExp(value)) {
        base = " " + RegExp.prototype.toString.call(value);
      }
      if (isDate(value)) {
        base = " " + Date.prototype.toUTCString.call(value);
      }
      if (isError(value)) {
        base = " " + this.formatError(value);
      }
      return {
        base: base,
        braces: braces,
        array: array
      };
    };

    Inspector.prototype.getKeys = function(value) {
      var keys, keysLimited, visibleKeys;
      keys = objectKeys(value);
      keysLimited = keys.length > this.ctx.keysLimit;
      if (keysLimited) {
        keys = keys.slice(0, (this.ctx.keysLimit - 1) + 1 || 9e9);
      }
      visibleKeys = arrayToHash(keys);
      try {
        if (this.ctx.showHidden && Object.getOwnPropertyNames) {
          keys = Object.getOwnPropertyNames(value);
        }
      } catch (_error) {}
      return {
        keys: keys,
        visibleKeys: visibleKeys,
        keysLimited: keysLimited
      };
    };

    Inspector.prototype.customFormat = function(value, recurseTimes) {
      var custom, ret;
      custom = this.ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== inspect && !(value.constructor && value.constructor.prototype.is(value));
      if (!custom) {
        return null;
      }
      ret = value.inspect(recurseTimes, this.ctx);
      if (!isString(ret)) {
        ret = this.formatValue(ret, recurseTimes);
      }
      return ret;
    };

    Inspector.prototype.stylize = function(value) {
      return this.ctx.stylize(value);
    };

    return Inspector;

  })();

  ObjectProperty = (function() {

    ObjectProperty.prototype.lf = "\n";

    function ObjectProperty(spec) {
      this.spec = spec;
      this.value = this.spec.value;
      this.key = this.spec.key;
      this.desc = {
        value: void 0
      };
      try {
        this.desc.value = this.value[this.key];
      } catch (_error) {}
      try {
        if (Object.getOwnPropertyDescriptor) {
          this.desc = Object.getOwnPropertyDescriptor(this.value, this.key) || desc;
        }
      } catch (_error) {}
    }

    ObjectProperty.prototype.format = function() {
      var name, str;
      str = this.val();
      if (this.spec.array && this.key.match(/^\d+$/)) {
        return str;
      }
      name = this.name(str);
      return "" + name + ":" + str;
    };

    ObjectProperty.prototype.name = function(str) {
      var name;
      if (!hasOwn(this.spec.visibleKeys, this.key)) {
        return "[" + this.key + "]";
      }
      name = JSON.stringify("" + this.key);
      if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
        name = name.substr(1, name.length - 2);
        name = this.stylize(name, "name");
      } else {
        name = name.replace(/'/g, "\\'").replace(/\\"/g, "\"").replace(/(^"|"$)/g, "'");
        name = this.stylize(name, "string");
      }
      return name;
    };

    ObjectProperty.prototype.val = function() {
      var array, l, lines, nextRecurse, spaces, str;
      if (str = this.getterSetter()) {
        return str;
      }
      if (this.spec.ctx.seen.indexOf(this.desc.value) !== -1) {
        return this.stylize("[Circular]", "special");
      }
      nextRecurse = isNull(this.spec.recurseTimes) ? null : this.spec.recurseTimes - 1;
      str = this.spec.formatValue(this.desc.value, nextRecurse);
      if (str.indexOf(this.lf) === -1) {
        return str;
      }
      lines = str.split("\n");
      array = this.spec.array;
      spaces = array ? "" : "";
      l = lines.map(function(line) {
        return spaces + line;
      }).join(this.lf);
      return str = array ? l.substr(0) : this.lf + l;
    };

    ObjectProperty.prototype.getterSetter = function() {
      var str;
      str = null;
      if (this.desc.get) {
        if (this.desc.set) {
          str(this.stylize("[Getter/Setter]", "special"));
        } else {
          str = this.stylize("[Getter]", "special");
        }
      } else if (this.desc.set) {
        str = this.stylize("[Setter]", "special");
      }
      return str;
    };

    ObjectProperty.prototype.stylize = function(x) {
      return this.spec.ctx.stylize(x);
    };

    return ObjectProperty;

  })();

  objectKeys = function(val) {
    if (Object.keys) {
      return Object.keys(val);
    }
  };

  _extend = function(origin, add) {
    var i, keys;
    if (!add || !isObject(add)) {
      return origin;
    }
    keys = objectKeys(add);
    i = keys.length;
    while (i--) {
      origin[keys[i]] = add[keys[i]];
    }
    return origin;
  };

  isArray = function(v) {
    return v.constructor === Array;
  };

  reduce = function(array, f) {
    if (!array) {
      return 0;
    }
    return array.reduce(f);
  };

  stylizeNoColor = function(str, styleType) {
    return str;
  };

  isBoolean = function(arg) {
    return typeof arg === "boolean";
  };

  isUndefined = function(arg) {
    return arg === void 0;
  };

  stylizeWithColor = function(str, styleType) {
    var style;
    style = inspect.styles[styleType];
    if (style) {
      return "\u001b[" + inspect.colors[style][0] + "m" + str + "\u001b[" + inspect.colors[style][1] + "m";
    } else {
      return str;
    }
  };

  isFunction = function(arg) {
    return typeof arg === "function";
  };

  isString = function(arg) {
    return typeof arg === "string";
  };

  isNumber = function(arg) {
    return typeof arg === "number";
  };

  isNull = function(arg) {
    return arg === null;
  };

  hasOwn = function(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  };

  isRegExp = function(re) {
    return isObject(re) && objectToString(re) === "[object RegExp]";
  };

  isObject = function(arg) {
    return typeof arg === "object" && arg !== null;
  };

  isError = function(e) {
    return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
  };

  isDate = function(d) {
    return isObject(d) && objectToString(d) === "[object Date]";
  };

  objectToString = function(o) {
    return Object.prototype.toString.call(o);
  };

  arrayToHash = function(array) {
    var hash, val, _i, _len;
    hash = {};
    for (_i = 0, _len = array.length; _i < _len; _i++) {
      val = array[_i];
      hash[val] = true;
    }
    return hash;
  };

  inspect.colors = {
    bold: [1, 22],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    white: [37, 39],
    grey: [90, 39],
    black: [30, 39],
    blue: [34, 39],
    cyan: [36, 39],
    green: [32, 39],
    magenta: [35, 39],
    red: [31, 39],
    yellow: [33, 39]
  };

  inspect.styles = {
    special: "cyan",
    number: "yellow",
    boolean: "yellow",
    undefined: "grey",
    "null": "bold",
    string: "green",
    date: "magenta",
    regexp: "red"
  };

  window.$inspect2 = inspect;

}).call(this);
